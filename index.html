<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel Crypto para Contrarians</title>
    <!-- Incluir Montserrat Font -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <!-- Incluir Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Incluir Chart.js para los gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABTSURBVDhPY2AYWfIe/1+GhEkgxYCYQYhFgE2I7Q0C7GAC2G8QJAUiXoYh/9mQ4W0KxALCg4/w/m5gUa2D/H+jKAgPz0Z+AQL/G0gxoBYc/g/wF+H/R1C9g0iPgD+B2YyRjO5zE4y7IYA3i3TfE8QZzL8g5h8XXp0+vJ957xGg8mUoAAAAASUVORK5CYII=">

    <style>
        /* Configuración de color y fuente para el estilo "minimalista y elegante" */
        :root {
            --bg-color: #0c0c0c; /* Fondo Oscuro (Deep Black) */
            --card-bg: #1a1a1a; /* Fondo de tarjeta un poco más claro */
            --text-color: #f0f6fc; /* Texto blanco/claro */
            --accent-color: #CCAA66; /* DORADO NUEVO: Más elegante, profesional y menos amarillo */
            --positive-color: #38a169; /* Verde para positivo */
            --negative-color: #e53e3e; /* Rojo para negativo */
            --fng-neutral-color: #ff9800; /* Naranja/Ámbar para neutral */
        }

        body {
            font-family: 'Montserrat', sans-serif; /* Usando Montserrat */
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Clase de utilidad para el texto dorado */
        .text-gold {
            color: var(--accent-color);
        }

        /* Estilo para el índice F&G */
        #fng-gauge {
            width: 100%;
            height: 10px;
            background: linear-gradient(to right, 
                #e53e3e, /* 0 (Miedo Extremo - Rojo) */
                #f6ad55, /* 25 (Miedo - Naranja suave) */
                #ff9800, /* 50 (Neutral - Naranja/Ámbar) */
                #48bb78, /* 75 (Codicia - Verde) */
                #CCAA66  /* 100 (Codicia Extrema - DORADO NUEVO) */
            );
            border-radius: 5px;
            margin-top: 0.5rem;
            position: relative;
        }

        #fng-pointer {
            position: absolute;
            top: -5px; /* Ajustar posición para centrar el marcador */
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid var(--text-color);
            transform: translateX(-50%); /* Centrar el triángulo en su posición */
        }
        /* Estilo para dar altura a los contenedores de gráficos */
        .chart-container {
            height: 350px; /* Altura fija para evitar problemas de relación de aspecto en un solo eje */
        }
    </style>
<link type="text/css" rel="stylesheet" href="css/style.css"/>
</head>
<body class="p-4 sm:p-8">

    <!-- CABECERA -->
    <header class="w-full mb-8 text-center">
        <div class="flex flex-col items-center justify-center">
            <!-- El texto principal AHORA ESTÁ EN DORADO, usando la clase text-gold -->
            <h1 class="text-3xl sm:text-4xl font-extrabold tracking-tight text-gold mb-1 mt-4">
                AV - Anastasia Volkova
            </h1>
            <p class="text-lg text-gray-500">
                Clarity in the crypto chaos
            </p>
            <!-- Título del panel en DORADO, único acento fuerte en el encabezado -->
            <h2 class="text-2xl mt-6 font-semibold border-b-2 border-accent-color pb-2 text-gold">
                Panel Crypto para Contrarians
            </h2>
        </div>
    </header>

    <!-- CUERPO PRINCIPAL -->
    <main class="flex-grow w-full max-w-7xl mx-auto">
        
        <!-- Estado de la Actualización -->
        <div class="text-center mb-6">
            <p id="last-update" class="text-sm text-gray-500">Última actualización: Cargando...</p>
        </div>

        <!-- Indicadores Clave (Precio BTC y F&G) -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-10">
            
            <!-- Tarjeta: Precio de BTC -->
            <div class="bg-card-bg p-6 rounded-xl shadow-lg">
                <!-- Título en DORADO -->
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gold">BTC/USD Spot</h3>
                    <!-- ÍCONO BTC AHORA EN DORADO (SVG) -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="h-6 w-6 text-gold">
                        <!-- Icono simple de moneda/circular para reemplazar la imagen de BTC -->
                        <path fill-rule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zM12.75 6a.75.75 0 00-1.5 0v6c0 .414.336.75.75.75h4.5a.75.75 0 000-1.5h-3.75V6z" clip-rule="evenodd" />
                    </svg>
                </div>
                <!-- Precio en DORADO -->
                <p id="btc-price" class="text-5xl font-extrabold text-gold">$0.00</p>
                <div class="mt-3 flex items-center">
                    <p class="text-lg mr-4 text-gray-400">Cambio 24h:</p>
                    <span id="btc-change-24h" class="text-lg font-semibold">-0.00%</span>
                </div>
            </div>

            <!-- Tarjeta: Índice de Miedo y Codicia (F&G) -->
            <div class="bg-card-bg p-6 rounded-xl shadow-lg">
                <!-- Título en DORADO -->
                <h3 class="text-xl font-bold text-gold">Índice de Miedo y Codicia</h3>
                
                <!-- Valor en DORADO -->
                <p id="fng-value" class="text-5xl font-extrabold text-gold">0</p>
                <p id="fng-status" class="text-xl mt-1 font-semibold text-fng-neutral-color">Cargando...</p>
                
                <!-- Indicador de Calibre (Gauge) -->
                <div id="fng-gauge-container" class="mt-4">
                    <div id="fng-gauge">
                        <div id="fng-pointer" style="left: 0%;"></div>
                    </div>
                    <div class="flex justify-between text-xs text-gray-400 mt-2">
                        <span>Miedo Extremo (0)</span>
                        <span>Codicia Extrema (100)</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Gráficos de Tendencia (Últimos 7 Días) -->
        <div class="grid grid-cols-1 gap-6">
            
            <!-- Gráfico 1: Cotización de BTC (Últimos 7 Días) -->
            <div class="bg-card-bg p-4 rounded-xl shadow-lg chart-container">
                <h3 class="text-lg font-semibold mb-3 text-gold">Cotización de BTC (Últimos 7 Días)</h3>
                <canvas id="btcPriceChart"></canvas>
            </div>
            
            <!-- Gráfico 2: Capitalización de Mercado (Últimos 7 Días) -->
            <div class="bg-card-bg p-4 rounded-xl shadow-lg chart-container">
                <!-- Título en DORADO -->
                <h3 class="text-lg font-semibold mb-3 text-gold">Capitalización de Mercado (Últimos 7 Días)</h3>
                <canvas id="marketCapChart"></canvas>
            </div>
            
            <!-- NUEVO Gráfico 3: Tendencia Global del Mercado -->
            <div class="bg-card-bg p-4 rounded-xl shadow-lg chart-container">
                <!-- Título en DORADO -->
                <h3 class="text-lg font-semibold mb-3 text-gold">Tendencia Global del Mercado (RSI, Volumen, F&G)</h3>
                <canvas id="globalTrendChart"></canvas>
            </div>

        </div>

    </main>

    <!-- PIE DE PÁGINA -->
    <footer class="w-full text-center mt-12 py-4 border-t border-gray-700">
        <p class="text-sm text-gray-500">
            &copy; <span id="current-year">2025</span> Copyright Anastasia Volkova
        </p>
    </footer>

    <!-- LÓGICA JAVASCRIPT -->
    <script>
        // Configuración de Chart.js para el modo oscuro
        Chart.defaults.color = 'var(--text-color)';
        Chart.defaults.borderColor = 'var(--card-bg)';
        
        // Inicialización de gráficos y variables globales
        let btcPriceChart, marketCapChart, globalTrendChart; 
        let fngHistory = []; // Variable global para almacenar el historial de F&G

        // URL de APIs
        const API_URLS = {
            // Coingecko: Precio actual y cambio 24h
            btcPrice: 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true',
            // Coingecko: Datos históricos de 7 días (precio, capitalización, volumen)
            btcHistorical: 'https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=7&interval=daily',
            // Alternative.me: Índice de Miedo y Codicia (incluye 7 días de historial)
            fngIndex: 'https://api.alternative.me/fng/?limit=7&format=json&date_format=dates',
        };

        // --- FUNCIONES PRINCIPALES DE FETCH Y ACTUALIZACIÓN ---

        /**
         * Función genérica para realizar fetch con manejo de errores y reintentos (backoff exponencial).
         * Muestra el error en la consola y propaga la excepción si falla.
         * @param {string} url - La URL del API.
         * @param {number} retries - Número de reintentos restantes.
         */
        async function fetchWithRetry(url, retries = 5) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.warn(`Intento ${i + 1} fallido para ${url}.`, error.message);
                    if (i === retries - 1) {
                        // Después del fallo final, lanzamos el error
                        throw new Error(`Fallo final al intentar obtener datos de: ${url}. Error: ${error.message}`); 
                    }
                    // Backoff exponencial para el reintento: 1s, 2s, 4s, 8s, ...
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }
        }

        /**
         * 1. Actualiza el precio de BTC y el cambio de 24h.
         */
        async function updateBtcPrice() {
            const data = await fetchWithRetry(API_URLS.btcPrice);
            
            const price = data.bitcoin.usd;
            const change = data.bitcoin.usd_24h_change;

            const priceElement = document.getElementById('btc-price');
            const changeElement = document.getElementById('btc-change-24h');

            // Formatear y actualizar el precio (con comas de miles y dos decimales)
            priceElement.textContent = `$${price.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ",")}`;
            
            // Actualizar el cambio de 24h y el estilo (verde si sube, rojo si baja)
            changeElement.textContent = `${change.toFixed(2)}%`;
            changeElement.className = change >= 0 
                ? 'text-lg font-semibold' + ' ' + 'text-positive-color' 
                : 'text-lg font-semibold' + ' ' + 'text-negative-color';
        }

        /**
         * 2. Actualiza el Índice de Miedo y Codicia (F&G) y almacena su historial.
         */
        async function updateFngIndex() {
            const data = await fetchWithRetry(API_URLS.fngIndex);

            // Almacenar el historial (últimos 7 días) y revertir para que sea cronológico (día 1 al día 7)
            fngHistory = data.data.slice(0, 7).reverse(); 

            // El último elemento (índice 6 después de revertir) es el valor más reciente
            const fngData = fngHistory[fngHistory.length - 1]; 
            const value = parseInt(fngData.value);
            const status = fngData.value_classification;

            const statusElement = document.getElementById('fng-status');
            
            // Mapear el valor F&G a un color para el estado
            let color;
            if (value <= 20) color = 'var(--negative-color)'; // Miedo Extremo
            else if (value <= 40) color = 'var(--fng-neutral-color)'; // Miedo 
            else if (value <= 60) color = 'var(--fng-neutral-color)'; // Neutral
            else if (value <= 80) color = 'var(--positive-color)'; // Codicia
            else color = 'var(--accent-color)'; // Codicia Extrema (DORADO)

            // Actualizar valores y estilo
            document.getElementById('fng-value').textContent = value;
            statusElement.textContent = status;
            statusElement.style.color = color;

            // Mover el indicador del calibre (0% a 100%)
            const pointer = document.getElementById('fng-pointer');
            pointer.style.left = `${value}%`;
        }

        // --- Lógica para el Índice de Sentimiento Global (GSS) ---
        
        /**
         * Calcula la media móvil simple (SMA) para un período.
         */
        function calculateSMA(data, period) {
            let sma = [];
            for (let i = 0; i < data.length; i++) {
                // Necesitamos 'period' días antes de calcular la primera SMA
                if (i < period - 1) {
                    sma.push(null); 
                } else {
                    const slice = data.slice(i - period + 1, i + 1);
                    const sum = slice.reduce((acc, val) => acc + val, 0);
                    sma.push(sum / period);
                }
            }
            return sma;
        }

        /**
         * Calcula el Índice de Sentimiento Global (GSS) combinando indicadores (0-100).
         * Componentes: F&G (50%), Price/MA (30%), Volumen (20%).
         */
        function calculateGlobalSentiment(prices, volumes, fngData) {
            // Extraer solo los valores de precio y volumen para los cálculos
            const prices7d = prices.map(item => item[1]);
            const volumes7d = volumes.map(item => item[1]);
            const fngValues7d = fngData.map(d => parseInt(d.value));

            // 1. Calcular 3-day SMA (Proxy de tendencia a corto plazo)
            const sma3 = calculateSMA(prices7d, 3);
            
            // 2. Calcular 7-day promedio de volumen
            const totalVolume = volumes7d.reduce((sum, vol) => sum + vol, 0);
            const avgVolume = totalVolume / volumes7d.length;

            const gssScores = [];

            for (let i = 0; i < 7; i++) {
                const fng = fngValues7d[i];
                const price = prices7d[i];
                const volume = volumes7d[i];
                const ma = sma3[i];

                let priceSentiment = 0; // Contribución de la tendencia del precio (máx 30)
                let volumeSentiment = 0; // Contribución del volumen (máx 20)
                
                // --- Price Trend Contribution (30%) ---
                if (ma !== null) {
                    const diff = price - ma;
                    const percentageDiff = diff / ma; 
                    
                    // Normalizar la diferencia: un 5% por encima de la MA3 ya es muy alcista (15 puntos swing)
                    // Score range: -15 to +15 (normalized to 0-30 max)
                    const rawScore = Math.max(-15, Math.min(15, percentageDiff * 300)); 
                    priceSentiment = rawScore + 15; // Normalizar a 0-30 range
                } else {
                    // Si la MA no está disponible (primeros 2 días), asignamos un valor neutral
                    priceSentiment = 15;
                }

                // --- Volume Contribution (20%) ---
                const volumeRatio = volume / avgVolume; 
                
                // Normalizar la contribución del volumen (10 puntos swing, 10-30 range)
                // Si el volumen es el doble del promedio (ratio=2), es +10. Si es 0.5 del promedio, es -10.
                const rawScore = Math.max(-10, Math.min(10, (volumeRatio - 1) * 10)); // Swing -10 to +10
                volumeSentiment = rawScore + 10; // Normalizar a 0-20 range

                // --- F&G Index (50%) ---
                // F&G ya es 0-100, así que lo dividimos por 2 para que contribuya con un máximo de 50
                const fngContribution = fng * 0.5; 
                
                // --- Combined Weighted Score (0-100) ---
                const finalGSS = fngContribution + priceSentiment + volumeSentiment;
                
                gssScores.push(Math.round(finalGSS));
            }

            return gssScores;
        }


        /**
         * 3. Actualiza los gráficos históricos de BTC (Precio, Market Cap y Tendencia Global).
         */
        async function updateBtcHistoricalCharts() {
            // Si el historial de F&G no está cargado, lo cargamos primero.
            if (fngHistory.length === 0) {
                 await updateFngIndex();
            }

            const data = await fetchWithRetry(API_URLS.btcHistorical);

            // Preparar datos: Fechas, Precios, Capitalizaciones, y VOLUMENES
            const dates = data.prices.map(item => new Date(item[0]).toLocaleDateString('es-ES', { day: 'numeric', month: 'short' }));
            const prices = data.prices; // [timestamp, price]
            const marketCaps = data.market_caps; // [timestamp, market_cap]
            const volumes = data.total_volumes; // [timestamp, total_volume]
            
            // Colores basados en el acento dorado (#CCAA66)
            const newGoldRgba = 'rgba(204, 170, 102, 0.2)'; // 20% opacidad para línea
            const newGoldRgbaBar = 'rgba(204, 170, 102, 0.4)'; // 40% opacidad para barras

            // --- Gráfico de Precio de BTC (Línea) ---
            if (!btcPriceChart) {
                const ctx = document.getElementById('btcPriceChart').getContext('2d');
                btcPriceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Precio BTC (USD)',
                            data: prices.map(item => item[1]),
                            borderColor: 'var(--accent-color)', 
                            backgroundColor: newGoldRgba, 
                            tension: 0.3,
                            fill: true,
                            pointRadius: 3,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false, 
                        scales: {
                            y: {
                                beginAtZero: false,
                                grid: { color: 'var(--card-bg)' },
                                ticks: { 
                                    // Formato de moneda para el eje Y
                                    callback: (value) => `$${value.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ",")}` 
                                }
                            },
                            x: { grid: { display: false } }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            } else {
                btcPriceChart.data.labels = dates;
                btcPriceChart.data.datasets[0].data = prices.map(item => item[1]);
                btcPriceChart.update();
            }

            // --- Gráfico de Capitalización de Mercado (Barras) ---
            if (!marketCapChart) {
                const ctx = document.getElementById('marketCapChart').getContext('2d');
                marketCapChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Capitalización de Mercado (USD)',
                            data: marketCaps.map(item => item[1]),
                            backgroundColor: newGoldRgbaBar, 
                            borderColor: 'var(--accent-color)', 
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false, 
                        scales: {
                            y: {
                                beginAtZero: false,
                                grid: { color: 'var(--card-bg)' },
                                ticks: { 
                                    // Muestra los ticks en Billones (miles de millones) con 'B'
                                    callback: (value) => `$${(value / 1e9).toFixed(0)}B` 
                                }
                            },
                            x: { grid: { display: false } }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            } else {
                marketCapChart.data.labels = dates;
                marketCapChart.data.datasets[0].data = marketCaps.map(item => item[1]);
                marketCapChart.update();
            }

            // --- NUEVO: Gráfico de Tendencia Global del Mercado (Línea) ---
            const globalSentimentScores = calculateGlobalSentiment(prices, volumes, fngHistory);
            
            if (!globalTrendChart) {
                const ctx = document.getElementById('globalTrendChart').getContext('2d');
                globalTrendChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Tendencia Global (0-100)',
                            data: globalSentimentScores,
                            borderColor: 'var(--accent-color)', 
                            backgroundColor: newGoldRgba, 
                            tension: 0.5, // Más suave
                            fill: true,
                            pointRadius: 4,
                            pointBackgroundColor: (context) => {
                                const value = context.dataset.data[context.dataIndex];
                                // Colores de los puntos según el sentimiento
                                if (value > 70) return 'var(--accent-color)'; // Bullish (Dorado)
                                if (value < 30) return 'var(--negative-color)'; // Bearish (Rojo)
                                return 'var(--fng-neutral-color)'; // Neutral (Naranja)
                            }
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false, 
                        scales: {
                            y: {
                                min: 0,
                                max: 100, // Escala fija para el índice 0-100
                                grid: { color: 'var(--card-bg)' },
                                ticks: { 
                                    callback: (value) => `${value}` 
                                }
                            },
                            x: { grid: { display: false } }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            } else {
                globalTrendChart.data.labels = dates;
                globalTrendChart.data.datasets[0].data = globalSentimentScores;
                globalTrendChart.update();
            }
        }
        
        /**
         * Función principal que llama a todas las actualizaciones.
         */
        async function updateDashboard() {
            let failedToFetchCount = 0;
            document.getElementById('last-update').textContent = 'Última actualización: Actualizando...';

            // 1. Ejecutar la función de F&G primero para asegurar que fngHistory se pueble
            const fngPromise = updateFngIndex().catch(e => { failedToFetchCount++; console.error("Error en updateFngIndex. El panel no mostrará datos F&G.", e); });
            await fngPromise;

            // 2. Ejecutar el resto de las actualizaciones en paralelo
            const updates = [
                updateBtcPrice().catch(e => { failedToFetchCount++; console.error("Error en updateBtcPrice. El panel no mostrará datos de precio.", e); }),
                updateBtcHistoricalCharts().catch(e => { failedToFetchCount++; console.error("Error en updateBtcHistoricalCharts. Los gráficos no se actualizarán.", e); })
            ];

            try {
                await Promise.all(updates);
            } catch (error) {
                // Este catch es para errores de ejecución no manejados
                console.error("Error fatal en la actualización del dashboard:", error);
            }

            // Actualizar la hora de la última actualización y mostrar el estado
            const now = new Date();
            const timeString = now.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            if (failedToFetchCount > 0) {
                document.getElementById('last-update').textContent = `Última actualización: ${timeString} (¡ERROR: ${failedToFetchCount} Fuentes fallaron!)`;
                document.getElementById('last-update').classList.add('text-negative-color');
            } else {
                document.getElementById('last-update').textContent = `Última actualización: ${timeString}`;
                document.getElementById('last-update').classList.remove('text-negative-color');
            }
        }

        /**
         * Inicialización de la aplicación.
         */
        window.onload = function() {
            // Inicializar el año en el pie de página
            const yearElement = document.getElementById('current-year');
            const currentYear = new Date().getFullYear();
            yearElement.textContent = currentYear >= 2025 ? currentYear : 2025;

            // Ejecutar la primera actualización inmediatamente
            updateDashboard();

            // Configurar el intervalo para actualizar cada 60 segundos (1 minuto)
            setInterval(updateDashboard, 60000);
        };
    </script>

<script type="text/javascript" src="js/script.js"></script>
</body>
</html>