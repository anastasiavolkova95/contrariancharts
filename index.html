<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel Crypto para Contrarians</title>
    <!-- Favicon usando el logo subido -->
    <link rel="icon" type="image/jpeg" href="Logo.jpeg">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

    <!-- Google Fonts: Montserrat para una estética limpia y moderna similar al logo -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600&display=swap" rel="stylesheet">

    <!-- Configuración de colores personalizados (Gold & Black Theme) -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'brand-black': '#050505',
                        'brand-card': '#111111',
                        'brand-gold': '#C49F57', // Dorado elegante
                        'brand-gold-light': '#E6C683',
                        'brand-gray': '#888888'
                    },
                    fontFamily: {
                        sans: ['Montserrat', 'sans-serif'],
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #050505;
            color: #E5E5E5;
        }
        /* Efecto de brillo dorado sutil en los bordes */
        .glass-panel {
            background: rgba(17, 17, 17, 0.95);
            border: 1px solid rgba(196, 159, 87, 0.2);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }
        .glass-panel:hover {
            border-color: rgba(196, 159, 87, 0.6);
            box-shadow: 0 0 15px rgba(196, 159, 87, 0.1);
        }
    </style>
<link type="text/css" rel="stylesheet" href="css/style.css"/>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Contenedor Principal -->
    <main class="w-full max-w-4xl space-y-8">
        
        <!-- Header con Logo -->
        <header class="text-center space-y-4 animate-fade-in">
            <div class="inline-block relative">
                <!-- Logo de Texto: "AV - Anastasia Volkova" -->
                <div class="p-4 rounded-xl shadow-lg border border-brand-gold/30 bg-brand-card mx-auto">
                    <h2 class="text-xl md:text-2xl font-light text-brand-gold tracking-widest whitespace-nowrap">
                        AV - Anastasia Volkova
                    </h2>
                </div>
            </div>
            <h1 class="text-3xl md:text-4xl font-light tracking-widest text-brand-gold uppercase">
                Panel Crypto para Contrarians
            </h1>
            <p class="text-brand-gray text-sm tracking-wider italic">
                "Clarity in the crypto chaos"
            </p>
        </header>

        <!-- Grid de Datos -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-8">
            
            <!-- Tarjeta 1: Bitcoin Price -->
            <div class="glass-panel rounded-xl p-8 text-center relative overflow-hidden group">
                <div class="absolute top-0 right-0 p-4 opacity-10">
                    <svg class="w-24 h-24 text-brand-gold" fill="currentColor" viewBox="0 0 24 24"><path d="M23.638 14.904c-1.602 6.43-8.113 10.34-14.542 8.736C2.67 22.05-1.244 15.525.362 9.105 1.962 2.67 8.475-1.24 14.9.358c6.43 1.605 10.341 8.115 8.738 14.548v-.002zm-6.394-5.553c.48-3.236-2.022-4.978-5.487-6.132l1.12-4.496-2.735-.682-1.092 4.384c-.718-.18-1.46-.34-2.193-.506l1.093-4.387-2.734-.68-1.118 4.48c-.6.15-1.18.298-1.748.44l-.014-.04-3.77 1.05.79 3.17s2.204-.552 2.164-.503c1.207.3 1.425 1.102 1.39 1.734l-1.395 5.597c.084.02.193.05.313.096-.1-.026-.207-.052-.308-.08l-.976 3.916c-.073.908-.64 2.272-2.456 1.82l-3.29-.817.653 2.62 5.093 1.27c.866.216 1.712.413 2.543.606l-1.134 4.544 2.735.682 1.115-4.476c.748.203 1.472.39 2.174.56l-1.112 4.464 2.736.68 1.13-4.526c4.66.882 8.165.526 9.64-3.69.19-3.085-1.523-4.864-3.565-5.717 1.238-.63 2.17-2.428 1.213-4.63zm-2.026 6.54c-.546 3.65-5.91 1.677-7.587 1.26l1.353-5.428c1.68.42 7.113 1.25 6.234 4.168zm.908-7.58c-.5 3.012-4.852 1.48-6.208 1.14l1.226-4.918c1.356.338 5.71 1.01 4.982 3.78z"/></svg>
                </div>
                
                <h2 class="text-brand-gray text-xs font-bold tracking-[0.2em] uppercase mb-2">Precio Actual</h2>
                <div class="flex items-center justify-center space-x-2">
                    <h3 class="text-4xl md:text-5xl font-light text-white" id="btc-price">
                        ---
                    </h3>
                    <span class="text-brand-gold text-xl animate-pulse-slow">USD</span>
                </div>
                <div class="mt-4 border-t border-brand-gold/20 pt-4 flex justify-between items-center text-sm">
                    <span class="text-brand-gray">Bitcoin (BTC)</span>
                    <span id="btc-change" class="font-bold">---</span>
                </div>
            </div>

            <!-- Tarjeta 2: Fear & Greed Index (Sentimiento Comunitario Actual) -->
            <div class="glass-panel rounded-xl p-8 text-center relative overflow-hidden">
                <div class="absolute top-0 right-0 p-4 opacity-10">
                    <svg class="w-24 h-24 text-brand-gold" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>
                </div>

                <h2 class="text-brand-gray text-xs font-bold tracking-[0.2em] uppercase mb-2">Sentimiento de Mercado (F&G)</h2>
                <div class="flex flex-col items-center justify-center">
                    <div class="relative">
                        <!-- Clases base del círculo - Solo las clases de color/sombra son dinámicas -->
                        <div id="fg-circle" class="w-24 h-24 rounded-full border-2 border-brand-gold/30 flex items-center justify-center mb-2 shadow-[0_0_15px_rgba(196,159,87,0.1)]">
                            <h3 class="text-4xl font-light text-white" id="fg-value">--</h3>
                        </div>
                    </div>
                    
                    <!-- Aviso de Datos Simulados (Invisible por defecto) -->
                    <span id="fg-warning" class="text-xs text-red-500 font-semibold mt-1 h-4 invisible transition-all duration-300">
                        ⚠️ Datos simulados
                    </span>
                    
                    <span id="fg-text" class="text-brand-gold font-semibold text-lg tracking-wide uppercase mt-1">
                        Cargando...
                    </span>
                    <!-- Indicador de Fuente -->
                    <span id="fg-provider" class="text-[10px] text-brand-gray/50 mt-1">
                        Fuente: Alternative.me
                    </span>
                    <!-- NUEVO: Indicador de estado de la conexión -->
                    <span id="fg-status-indicator" class="text-[10px] mt-1 font-semibold text-brand-gray">
                        Conectando...
                    </span>
                </div>
                <div class="mt-4 border-t border-brand-gold/20 pt-4 text-sm text-brand-gray italic">
                    "Be fearful when others are greedy"
                </div>
            </div>
        </div>

        <!-- Tarjeta 3: Gráfico de Cotización (7 Días) -->
        <div class="glass-panel rounded-xl p-6 md:p-8 mt-6">
            <h2 class="text-brand-gray text-xs font-bold tracking-[0.2em] uppercase mb-4 text-center">
                Cotización de BTC (Últimos 7 Días)
            </h2>
            <!-- Contenedor del gráfico de Precio -->
            <div id="btc-chart-container" class="relative h-64">
                <canvas id="btc-chart"></canvas>
            </div>
        </div>

        <!-- Tarjeta 4: Gráfico de Market Cap (7 Días) -->
        <div class="glass-panel rounded-xl p-6 md:p-8 mt-6">
            <h2 class="text-brand-gray text-xs font-bold tracking-[0.2em] uppercase mb-4 text-center">
                Capitalización de Mercado (Últimos 7 Días)
            </h2>
            <!-- Contenedor del gráfico de Market Cap -->
            <div id="mktcap-chart-container" class="relative h-64">
                <canvas id="mktcap-chart"></canvas>
            </div>
        </div>

        <!-- Tarjeta 5: Gráfico de Sentimiento Comunitario (7 Días) -->
        <div class="glass-panel rounded-xl p-6 md:p-8 mt-6">
            <h2 class="text-brand-gray text-xs font-bold tracking-[0.2em] uppercase mb-4 text-center">
                Sentimiento Comunitario (Tendencia F&G 7 Días)
            </h2>
            <!-- Contenedor del gráfico de Sentimiento -->
            <div id="fg-chart-container" class="relative h-64">
                <canvas id="fg-chart"></canvas>
            </div>
        </div>

        <!-- Footer / Status -->
        <footer class="text-center space-y-2 pt-8">
            <div class="inline-flex items-center space-x-2 px-4 py-1 rounded-full border border-brand-gold/20 bg-brand-card/50">
                <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                <p class="text-xs text-brand-gray font-mono">
                    Última actualización: <span id="last-updated" class="text-brand-gold">--:--:--</span>
                </p>
            </div>
            
            <!-- Pie de página de Copyright con año dinámico/inline para exportación -->
            <p class="text-xs text-brand-gray pt-2">
                © <span id="copyright-year">2025</span> Copyright - Anastasia Volkova
            </p>

            <p class="text-[10px] text-zinc-700 uppercase tracking-widest mt-4">Powered by CoinGecko, CoinCap, Binance & Alternative.me</p>
        </footer>

    </main>

    <script>
        // --- CONSTANTES DE CONFIGURACIÓN ---
        const REFRESH_INTERVAL = 300000; // 5 minutos 
        const FNG_API_URL = 'https://api.alternative.me/fng/?limit=7&date_format=month-day-year'; // API para Fear & Greed Index
        
        let btcChartInstance = null;
        let mktCapChartInstance = null;
        let fgChartInstance = null; 
        
        // Variables globales para almacenar mock data de Sentimiento, para asegurar estabilidad si la API falla repetidamente
        let mockHistoricalData = null; 

        // --- Función de Utilidad para Reintentos ---
        async function fetchWithRetry(url, maxRetries = 5, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        if (response.status === 429 && i < maxRetries - 1) {
                            console.warn(`Retry ${i + 1}: Rate limit (429) hit for ${url}. Backing off...`);
                        } else {
                            // Este error ahora se propaga con el status code HTTP
                            throw new Error(`HTTP error! status: ${response.status} from ${url}`);
                        }
                    } else {
                         const data = await response.json();
                         if (!data || (Array.isArray(data) && data.length === 0) || (typeof data === 'object' && Object.keys(data).length === 0)) {
                             throw new Error(`Empty or invalid data from ${url}`);
                         }
                         return { data, source: new URL(url).hostname };
                    }
                } catch (error) {
                    // Solo loguea el error en los reintentos
                    if (i < maxRetries - 1) {
                        console.warn(`Fetch attempt ${i + 1} failed for ${url}. Error:`, error.message);
                    }
                    if (i === maxRetries - 1) {
                        // Lanza el error fatal en el último intento
                        throw error; 
                    }
                    // Implementa backoff exponencial
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                }
            }
        }
        // -------------------------------------------
        
        // --- Helpers de UI y Estado ---

        // Función para recrear el elemento canvas si no existe
        function ensureCanvas(containerId, canvasId) {
            const container = document.getElementById(containerId);
            if (container && container.querySelector('canvas') === null) {
                container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
            }
        }

        // Función para mostrar un mensaje de error en lugar del gráfico
        function displayChartError(containerId, message) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const chartId = containerId.replace('-container', '');
            
            // 1. Destruir la instancia de Chart.js si existe
            if (chartId === 'btc-chart' && btcChartInstance) {
                btcChartInstance.destroy();
                btcChartInstance = null;
            } else if (chartId === 'mktcap-chart' && mktCapChartInstance) {
                mktCapChartInstance.destroy();
                mktCapChartInstance = null;
            } else if (chartId === 'fg-chart' && fgChartInstance) { 
                fgChartInstance.destroy();
                fgChartInstance = null;
            }

            // 2. Reemplazar el contenido del contenedor con el mensaje de error
            container.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full text-center p-4">
                    <p class="text-xl text-red-500 font-bold mb-2">¡Error al Cargar Gráfico!</p>
                    <p class="text-sm text-brand-gray">${message}</p>
                    <p class="text-xs text-brand-gray/50 mt-1">Reintentando en ${REFRESH_INTERVAL/60000} minutos.</p>
                </div>
            `;
        }


        // Función Helper para actualizar la UI del precio de BTC
        function updateBTCUI(price, change) {
            // Formatear precio
            document.getElementById('btc-price').innerText = `$${price.toLocaleString('en-US', {maximumFractionDigits: 0})}`;
            
            // Formatear cambio 24h
            const changeElem = document.getElementById('btc-change');
            const changeFormatted = change.toFixed(2) + '%';
            
            if (change > 0) {
                changeElem.innerText = `+${changeFormatted}`;
                changeElem.className = "font-bold text-green-500"; // Verde discreto
            } else {
                changeElem.innerText = `${changeFormatted}`;
                changeElem.className = "font-bold text-red-500"; // Rojo discreto
            }
        }
        
        // --- Función: Obtener Precio Actual (para la tarjeta superior) ---
        async function fetchBTC() {
            let price, change;
            
            // 1. Primary: CoinGecko (usando el endpoint de 'markets' más robusto)
            const coinGeckoUrl = 'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=bitcoin&price_change_percentage=24h&per_page=1&page=1';
            try {
                const { data } = await fetchWithRetry(coinGeckoUrl);
                // La respuesta es un array, tomamos el primer elemento [0]
                const btcData = data[0]; 
                if (!btcData) throw new Error("CoinGecko data array is empty.");
                
                price = btcData.current_price;
                // API proporciona el porcentaje de cambio en 24h
                change = btcData.price_change_percentage_24h; 
                console.log("BTC Price Success: Fetched price from CoinGecko.");
            } catch (cgError) {
                console.warn("CoinGecko simple price failed. Intentando CoinCap fallback.");
                
                // 2. Fallback: CoinCap
                const coinCapUrl = 'https://api.coincap.io/v2/assets/bitcoin';
                try {
                    const { data } = await fetchWithRetry(coinCapUrl);
                    const btcData = data.data;
                    price = parseFloat(btcData.priceUsd);
                    // CoinCap proporciona el porcentaje de cambio en 24h (String)
                    change = parseFloat(btcData.changePercent24Hr);
                    console.log("BTC Price Success: Fetched price from CoinCap.");
                } catch (ccError) {
                    console.error("Ambas APIs de precio actual fallaron.", ccError);
                    // Mostrar error en la UI de precio
                    document.getElementById('btc-price').innerText = "---";
                    document.getElementById('btc-change').innerText = "API Error";
                    document.getElementById('btc-change').className = "font-bold text-red-500";
                    return; 
                }
            }

            // Update UI with the successfully fetched data (from CG or CC)
            if (price && change !== undefined) {
                updateBTCUI(price, change);
            }
        }
        
        // --- Funciones de Datos de Sentimiento (F&G) ---

        // Función de Fallback (Datos simulados) - Ahora genera datos estables para el gráfico
        function getMockSentimentData() {
            // Generar datos históricos solo la primera vez que falla
            if (!mockHistoricalData) {
                const generatedData = [];
                const now = new Date();
                const randSeed = Math.random() * 100;

                for (let i = 6; i >= 0; i--) {
                    const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
                    // Simulación estable de tendencia + pequeño offset aleatorio
                    let value = 50 + Math.sin(i * 0.5 + randSeed) * 35 + (Math.random() * 10 - 5); 
                    value = Math.round(Math.max(10, Math.min(90, value)));
                    
                    let classification = 'Neutral';
                    if (value <= 25) classification = 'Miedo Extremo';
                    else if (value <= 49) classification = 'Miedo';
                    else if (value <= 75) classification = 'Avaricia';
                    else classification = 'Avaricia Extrema';

                    generatedData.push({
                        value: String(value),
                        value_classification: classification,
                        // Formato de fecha MM-DD
                        date: date.toLocaleDateString('es-ES', { month: 'numeric', day: 'numeric' })
                    });
                }
                mockHistoricalData = generatedData;
            }

            // Usar el punto más reciente como base para el "current" value
            const baseValue = parseInt(mockHistoricalData[mockHistoricalData.length - 1].value);

            // Aumento de Jitter para asegurar que el valor actual cambie VISIBLEMENTE si la API falla
            let jitter = Math.floor(Math.random() * 7) - 3; // -3, -2, -1, 0, 1, 2, or 3
            let currentValue = Math.max(10, Math.min(90, baseValue + jitter));
            
            let classification = 'Neutral';
            if (currentValue <= 25) classification = 'Miedo Extremo';
            else if (currentValue <= 49) classification = 'Miedo';
            else if (currentValue <= 75) classification = 'Avaricia';
            else classification = 'Avaricia Extrema';

            console.warn(`Usando datos simulados para Sentimiento (F&G). Valor actual simulado: ${currentValue}`);
            return {
                current: {
                    value: String(currentValue),
                    value_classification: classification,
                },
                historical: mockHistoricalData.map(item => ({ date: item.date, value: parseInt(item.value) })),
                source: "Mock Data (API Fallida)"
            };
        }

        // Función que consume y parsea el API de Alternative.me
        async function fetchSentimentFromAlternative() {
            const statusElem = document.getElementById('fg-status-indicator');
            statusElem.innerText = "Intentando conexión...";
            statusElem.className = "text-yellow-500";
            
            try {
                // Usar el fetchWithRetry definido anteriormente
                const { data, source } = await fetchWithRetry(FNG_API_URL);
                
                // 1. Verificar la estructura básica de la respuesta (AÑADIDO: Array.isArray)
                if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {
                    throw new Error("Datos de Alternative.me: Respuesta vacía o formato incorrecto.");
                }
                
                // FIX CLAVE: Filtrar datos corruptos antes de procesar
                const cleanData = data.data.filter(item => 
                    item && 
                    typeof item.value === 'string' && 
                    typeof item.value_classification === 'string' && 
                    typeof item.date === 'string' && 
                    item.date.length >= 5
                );
                
                if (cleanData.length === 0) {
                    // Este es el error reportado: ocurre cuando el filtro descarta todo
                    throw new Error("Datos de Alternative.me: Todos los puntos de datos están corruptos o faltan.");
                }

                // API returns newest first. Reverse for chronological chart order.
                const historicalData = cleanData.slice(0, 7).reverse(); 
                
                // The most current data is the last element in the reversed array (newest data point)
                const latestData = historicalData[historicalData.length - 1]; 
                
                console.log("F&G Data Success: Fetched real data from Alternative.me.");

                // Si la API tiene éxito, reiniciamos el mockHistoricalData
                mockHistoricalData = null; 
                
                // ACTUALIZAR INDICADOR DE ÉXITO
                statusElem.innerText = "Conexión OK";
                statusElem.className = "text-green-500";

                return {
                    current: {
                        value: latestData.value,
                        value_classification: latestData.value_classification
                    },
                    historical: historicalData.map(item => ({ 
                        // Formato de fecha MM-DD. El item.date ahora está garantizado como string válido.
                        date: item.date.substring(0, 5), 
                        value: parseInt(item.value) 
                    })),
                    source: source
                };

            } catch (error) {
                // REGISTRO DE ERROR DETALLADO EN CONSOLA
                console.error("F&G API Detailed Error:", error);
                
                // ACTUALIZAR INDICADOR DE ERROR
                const errorMessage = error.message || "Error de red desconocido";
                statusElem.innerText = `Error: ${errorMessage.substring(0, 40)}...`; 
                statusElem.className = "text-red-500";
                
                throw error; // Lanzar para ir al fallback final (Mock Data)
            }
        }
        
        // Función Maestra para obtener Sentimiento (F&G Index) y su Historial
        async function fetchSentimentData() {
            let dataPackage;
            
            // Intento 1: Proveedor principal (Alternative.me)
            try {
                dataPackage = await fetchSentimentFromAlternative();
            } catch (e) {
                // Fallback final: Datos simulados
                dataPackage = getMockSentimentData();
            }

            try {
                // --- Actualizar el Card de Valor Actual (Card 2) ---
                const { current, historical, source } = dataPackage;
                
                const value = current.value;
                const classification = current.value_classification;
                const isMock = source.includes("Mock Data"); // Verificar si se usó el fallback

                // Referencia al nuevo elemento de aviso
                const fgWarning = document.getElementById('fg-warning');
                
                // Mostrar/Ocultar el aviso de datos simulados
                if (isMock) {
                    fgWarning.classList.remove('invisible');
                    fgWarning.classList.add('visible');
                    fgWarning.title = "La conexión falló. Se están usando datos simulados para el índice F&G.";
                } else {
                    fgWarning.classList.add('invisible');
                    fgWarning.classList.remove('visible');
                    fgWarning.title = "";
                }

                document.getElementById('fg-value').innerText = value;
                document.getElementById('fg-text').innerText = classification;
                document.getElementById('fg-provider').innerText = `Fuente: ${source}`;


                // Lógica de color y borde actualizada
                const fgText = document.getElementById('fg-text');
                const fgCircle = document.getElementById('fg-circle');
                const numericValue = parseInt(value);

                let color;
                let borderColorClass; // Tailwind class for border
                let shadowColorClass; // Tailwind class for shadow

                if (numericValue < 20) { // Miedo Extremo (0-19)
                    color = "#f87171"; // Red-400
                    borderColorClass = "border-red-500/80";
                    shadowColorClass = "shadow-[0_0_15px_rgba(248,113,113,0.3)]";
                } else if (numericValue < 40) { // Miedo (20-39)
                    color = "#fb923c"; // Orange-400
                    borderColorClass = "border-orange-500/80";
                    shadowColorClass = "shadow-[0_0_15px_rgba(251,146,60,0.3)]";
                } else if (numericValue <= 60) { // Neutral (40-60)
                    color = "#C49F57"; // Gold (Neutral)
                    borderColorClass = "border-brand-gold/50";
                    shadowColorClass = "shadow-[0_0_15px_rgba(196,159,87,0.15)]";
                } else if (numericValue <= 80) { // Avaricia (61-80)
                    color = "#4ade80"; // Green-400
                    borderColorClass = "border-green-500/80";
                    shadowColorClass = "shadow-[0_0_15px_rgba(74,222,128,0.3)]";
                } else { // Avaricia Extrema (81-100)
                    color = "#34d399"; // Emerald-400
                    borderColorClass = "border-emerald-500/80";
                    shadowColorClass = "shadow-[0_0_15px_rgba(52,211,163,0.3)]";
                }

                // Aplicar color de texto
                fgText.style.color = color;

                // --- MANIPULACIÓN SEGURA DE CLASES DEL CÍRCULO ---
                if (fgCircle) {
                    const classList = fgCircle.classList;
                    
                    // 1. Eliminar clases de color/sombra anteriores (más seguro que regex)
                    const oldDynamicClasses = Array.from(classList).filter(c => 
                        (c.startsWith('border-') && !c.includes('border-2') && !c.includes('brand-gold/30')) || 
                        c.startsWith('shadow-[')
                    );
                    oldDynamicClasses.forEach(c => classList.remove(c));

                    // 2. Asegurar que las clases base estén presentes (default gold border y shadow)
                    classList.add('border-brand-gold/30');
                    classList.add('shadow-[0_0_15px_rgba(196,159,87,0.1)]');
                    
                    // 3. Aplicar nuevas clases dinámicas, reemplazando las de gold si es necesario
                    if (borderColorClass !== "border-brand-gold/50") {
                        classList.remove('border-brand-gold/30');
                        classList.add(borderColorClass);
                    }
                    if (shadowColorClass !== "shadow-[0_0_15px_rgba(196,159,87,0.15)]") {
                         classList.remove('shadow-[0_0_15px_rgba(196,159,87,0.1)]');
                         classList.add(shadowColorClass);
                    } else {
                         // Si es neutral, aseguramos la sombra ligera default
                         classList.add('shadow-[0_0_15px_rgba(196,159,87,0.1)]');
                    }
                }
                // --- FIN DE CORRECCIÓN ---


                // --- Renderizar el Gráfico Histórico (Card 5) ---
                const labels = historical.map(item => item.date);
                const values = historical.map(item => item.value);

                renderFGChart(labels, values);

            } catch (error) {
                console.error("Error procesando o renderizando Sentimiento:", error);
                
                // Asegurar que el aviso se muestre incluso si el procesamiento del mock data fallara (muy improbable)
                document.getElementById('fg-warning').classList.remove('invisible');
                document.getElementById('fg-warning').title = "Error irrecuperable de la API y el fallback.";

                // Actualizar UI con error
                document.getElementById('fg-value').innerText = "---";
                document.getElementById('fg-text').innerText = "Error API";
                document.getElementById('fg-text').style.color = "#ef4444";
                document.getElementById('fg-provider').innerText = `Fuente: Fallida`;
                
                // Resetear el borde del círculo a la configuración de error (rojo)
                const fgCircle = document.getElementById('fg-circle');
                if (fgCircle) {
                    const classList = fgCircle.classList;
                    // Limpiar clases de color/sombra anteriores (método seguro)
                    const oldDynamicClasses = Array.from(classList).filter(c => 
                        (c.startsWith('border-') && !c.includes('border-2')) || 
                        c.startsWith('shadow-[')
                    );
                    oldDynamicClasses.forEach(c => classList.remove(c));

                    // Aplicar clases de error (Rojo)
                    classList.add('border-red-500/80');
                    classList.add('shadow-[0_0_15px_rgba(248,113,113,0.3)]');
                }


                displayChartError('fg-chart-container', 'Falla al cargar la tendencia histórica del sentimiento.');
            }
        }
        
        // --- Funciones de Gráficos (sin cambios en renderizado, solo en la obtención de datos) ---

        // Función para renderizar el gráfico de PRECIO usando Chart.js
        function renderPriceChart(labels, values) {
            // Asegurar que el canvas existe
            ensureCanvas('btc-chart-container', 'btc-chart');

            const ctx = document.getElementById('btc-chart').getContext('2d');

            // Destruir instancia anterior si existe
            if (btcChartInstance) {
                btcChartInstance.destroy();
                btcChartInstance = null;
            }
            
            // Determinar el color de la línea
            const lineColor = values[values.length - 1] >= values[0] ? '#22c55e' : '#ef4444'; 

            btcChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Precio BTC (USD)',
                        data: values,
                        borderColor: lineColor,
                        backgroundColor: 'rgba(196, 159, 87, 0.1)', 
                        tension: 0.4, 
                        pointRadius: 0, 
                        borderWidth: 2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            display: true,
                            title: { display: false },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#888888', maxRotation: 0, autoSkip: true, maxTicksLimit: 7 }
                        },
                        y: {
                            display: true,
                            title: { display: true, text: 'Precio (USD)', color: '#C49F57' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: {
                                color: '#E5E5E5',
                                callback: function(value) {
                                    return '$' + value.toLocaleString('en-US', {maximumFractionDigits: 0});
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(17, 17, 17, 0.95)', 
                            titleColor: '#E6C683',
                            bodyColor: '#E5E5E5',
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) {
                                        label += new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Función para renderizar el gráfico de MARKET CAP usando Chart.js
        function renderMarketCapChart(labels, values) {
            // Asegurar que el canvas existe
            ensureCanvas('mktcap-chart-container', 'mktcap-chart');

            const ctx = document.getElementById('mktcap-chart').getContext('2d');

            // Destruir instancia anterior si existe
            if (mktCapChartInstance) {
                mktCapChartInstance.destroy();
                mktCapChartInstance = null;
            }
            
            // Determinar el color de la línea
            const lineColor = values[values.length - 1] >= values[0] ? '#22c55e' : '#ef4444'; 

            mktCapChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Capitalización de Mercado (USD)',
                        data: values,
                        borderColor: lineColor,
                        backgroundColor: 'rgba(196, 159, 87, 0.1)', 
                        tension: 0.4, 
                        pointRadius: 0, 
                        borderWidth: 2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            display: true,
                            title: { display: false },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#888888', maxRotation: 0, autoSkip: true, maxTicksLimit: 7 }
                        },
                        y: {
                            display: true,
                            title: { display: true, text: 'Market Cap (USD)', color: '#C49F57' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: {
                                color: '#E5E5E5',
                                callback: function(value) {
                                    // Formatear en Billones (B) o Trillones (T)
                                    if (value >= 1e12) {
                                        return '$' + (value / 1e12).toFixed(1) + 'T';
                                    }
                                    if (value >= 1e9) {
                                        return '$' + (value / 1e9).toFixed(1) + 'B';
                                    }
                                    return '$' + value.toLocaleString('en-US', {maximumFractionDigits: 0});
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(17, 17, 17, 0.95)', 
                            titleColor: '#E6C683',
                            bodyColor: '#E5E5E5',
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) {
                                        const value = context.parsed.y;
                                        if (value >= 1e12) {
                                            label += new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(value / 1e12) + 'T';
                                        } else if (value >= 1e9) {
                                            label += new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(value / 1e9) + 'B';
                                        } else {
                                            label += new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(value);
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Función para renderizar el gráfico de SENTIMIENTO (F&G) usando Chart.js
        function renderFGChart(labels, values) {
            // Asegurar que el canvas existe
            ensureCanvas('fg-chart-container', 'fg-chart');

            const ctx = document.getElementById('fg-chart').getContext('2d');

            // Destruir instancia anterior si existe
            if (fgChartInstance) {
                fgChartInstance.destroy();
                fgChartInstance = null;
            }
            
            // Determinar el color de la línea: verde si > 50 (Greed/Bullish), rojo si < 50 (Fear/Bearish)
            const lineColor = values[values.length - 1] > 50 ? '#22c55e' : '#ef4444'; 

            fgChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Índice F&G',
                        data: values,
                        backgroundColor: 'rgba(196, 159, 87, 0.1)', // Sutil área de fondo
                        borderColor: lineColor, 
                        borderWidth: 2,
                        tension: 0.4,
                        pointRadius: 3, // Puntos visibles
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            display: true,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#888888', maxRotation: 0, autoSkip: true, maxTicksLimit: 7 }
                        },
                        y: {
                            display: true,
                            min: 0, 
                            max: 100,
                            title: { display: true, text: 'Sentimiento % (Bullish / Bearish)', color: '#C49F57' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: {
                                color: '#E5E5E5',
                                callback: function(value) {
                                    if (value === 50) return 'Neutral (50)';
                                    if (value > 50) return `+${value - 50}% Bullish`;
                                    if (value < 50) return `${value - 50}% Bearish`; 
                                    return value;
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(17, 17, 17, 0.95)', 
                            titleColor: '#E6C683',
                            bodyColor: '#E5E5E5',
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    const diff = value - 50;
                                    let classification;

                                    if (value <= 19) classification = 'Miedo Extremo';
                                    else if (value <= 39) classification = 'Miedo';
                                    else if (value <= 60) classification = 'Neutral';
                                    else if (value <= 80) classification = 'Avaricia';
                                    else classification = 'Avaricia Extrema';

                                    return `${value} (${classification})`;
                                }
                            }
                        }
                    }
                }
            });
        }


        // Función para obtener y renderizar AMBOS gráficos de BTC (Precio y Market Cap)
        async function fetchBTCChartData() {
            let prices = null;
            let marketCaps = null;

            // --- Intento 1: CoinGecko (Principal, con Retries) ---
            try {
                const { data: cgData } = await fetchWithRetry('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=7');

                prices = cgData.prices;
                marketCaps = cgData.market_caps;
                
                // ÉXITO CG: Renderizar ambos
                const labels = prices.map(p => new Date(p[0]).toLocaleDateString('es-ES', { month: 'numeric', day: 'numeric' }));
                renderPriceChart(labels, prices.map(p => p[1]));
                renderMarketCapChart(labels, marketCaps.map(p => p[1]));
                return;

            } catch (cgError) {
                console.warn("CoinGecko histórico falló. Intentando CoinCap fallback para el Precio.");
                
                // --- Intento 2: CoinCap (Fallback para Precio) - AHORA CON fetchWithRetry
                try {
                    const { data: ccData } = await fetchWithRetry('https://api.coincap.io/v2/assets/bitcoin/history?interval=d1&limit=7');
                    
                    // Normalizar CoinCap data (timestamp, price)
                    prices = ccData.data.map(item => [item.time, parseFloat(item.priceUsd)]);

                    // ÉXITO CC: Renderizar solo Precio, el Market Cap muestra error
                    const labels = prices.map(p => new Date(p[0]).toLocaleDateString('es-ES', { month: 'numeric', day: 'numeric' }));
                    renderPriceChart(labels, prices.map(p => p[1]));
                    displayChartError('mktcap-chart-container', 'La Capitalización de Mercado no está disponible con la API de respaldo.');
                    return;

                } catch (ccError) {
                    console.warn("CoinCap histórico falló. Intentando Binance fallback para el Precio.");
                    
                    // --- Intento 3: Binance Klines (Fallback Final para Precio) - AHORA CON fetchWithRetry
                    try {
                        const { data: binanceData } = await fetchWithRetry('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1d&limit=7');

                        // Normalizar Binance Klines data (timestamp [0], close price [4])
                        prices = binanceData.map(item => [item[0], parseFloat(item[4])]);

                        // ÉXITO BINANCE: Renderizar solo Precio, el Market Cap muestra error
                        const labels = prices.map(p => new Date(p[0]).toLocaleDateString('es-ES', { month: 'numeric', day: 'numeric' }));
                        renderPriceChart(labels, prices.map(p => p[1]));
                        displayChartError('mktcap-chart-container', 'La Capitalización de Mercado no está disponible con la API de respaldo.');
                        return;

                    } catch (binanceError) {
                        console.error("Ambas APIs de gráficos fallaron:", binanceError);
                        // Mostrar error en ambos gráficos
                        displayChartError('btc-chart-container', 'Falla de conexión principal y de respaldo.');
                        displayChartError('mktcap-chart-container', 'Falla de conexión principal.');
                    }
                }
            }
        }

        // Función Maestra de Actualización
        function updateDashboard() {
            console.log("--- Panel: Iniciando ciclo de actualización de datos... ---");
            
            // Verificación ligera de que Chart.js esté cargado
            if (typeof Chart === 'undefined') {
                 console.error("Chart.js no está cargado.");
                 return;
            }

            try {
                // LLamada a la nueva función fetchBTC para obtener el precio actual
                fetchBTC(); 
                fetchSentimentData(); 
                fetchBTCChartData(); 
            } catch (e) {
                console.error("Error inesperado en updateDashboard:", e);
            }
            
            // Actualizar hora
            const now = new Date();
            const timeString = now.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            document.getElementById('last-updated').innerText = timeString;
            console.log(`--- Panel: Ciclo de actualización finalizado a las ${timeString} ---`);
        }

        // Iniciar
        document.addEventListener('DOMContentLoaded', () => {
            updateDashboard(); // Primera carga
            setInterval(updateDashboard, REFRESH_INTERVAL); // Intervalo cada 5 minutos

            // Código para actualizar solo el año dentro del span
            const currentYear = new Date().getFullYear();
            document.getElementById('copyright-year').innerText = currentYear;
        });

    </script>
<script type="text/javascript" src="js/script.js"></script>
</body>
</html>